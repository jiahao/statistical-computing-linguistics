\documentclass{article}

\usepackage{microtype}
\usepackage{hyperref}
\usepackage{listings}

% Use an APL-friendly font
\usepackage{fontspec}
%Download this font from
%http://misc.aplteam.com/apl385.ttf
\setmonofont{APL385}

\lstdefinelanguage{julia}{
  basicstyle=\small\ttfamily,
  showspaces=false,
  showstringspaces=false,
  keywordstyle={\textbf},
  morekeywords={if,else,elseif,while,for,begin,end,quote,try,catch,return,local,abstract,function,generated,macro,ccall,finally,typealias,break,continue,type,global,module,using,import,export,const,let,bitstype,do,in,baremodule,importall,immutable},
  escapeinside={~}{~},
  morecomment=[l]{\#},
  commentstyle={},
  morestring=[b]",
}
\lstset{language=julia, numbers=left, numberstyle=\tiny, mathescape=true}

% https://analyzethedatanotthedrivel.org/2011/08/15/typesetting-utf8-apl-code-with-the-latex-lstlisting-package/
% set lstlisting to accept UTF8 APL text
\makeatletter
\lst@InputCatcodes
\def\lst@DefEC{%
 \lst@CCECUse \lst@ProcessLetter
  ^^80^^81^^82^^83^^84^^85^^86^^87^^88^^89^^8a^^8b^^8c^^8d^^8e^^8f%
  ^^90^^91^^92^^93^^94^^95^^96^^97^^98^^99^^9a^^9b^^9c^^9d^^9e^^9f%
  ^^a0^^a1^^a2^^a3^^a4^^a5^^a6^^a7^^a8^^a9^^aa^^ab^^ac^^ad^^ae^^af%
  ^^b0^^b1^^b2^^b3^^b4^^b5^^b6^^b7^^b8^^b9^^ba^^bb^^bc^^bd^^be^^bf%
  ^^c0^^c1^^c2^^c3^^c4^^c5^^c6^^c7^^c8^^c9^^ca^^cb^^cc^^cd^^ce^^cf%
  ^^d0^^d1^^d2^^d3^^d4^^d5^^d6^^d7^^d8^^d9^^da^^db^^dc^^dd^^de^^df%
  ^^e0^^e1^^e2^^e3^^e4^^e5^^e6^^e7^^e8^^e9^^ea^^eb^^ec^^ed^^ee^^ef%
  ^^f0^^f1^^f2^^f3^^f4^^f5^^f6^^f7^^f8^^f9^^fa^^fb^^fc^^fd^^fe^^ff%
  ^^^^20ac^^^^0153^^^^0152%
  ^^^^20a7^^^^2190^^^^2191^^^^2192^^^^2193^^^^2206^^^^2207^^^^220a%
  ^^^^2218^^^^2228^^^^2229^^^^222a^^^^2235^^^^223c^^^^2260^^^^2261%
  ^^^^2262^^^^2264^^^^2265^^^^2282^^^^2283^^^^2296^^^^22a2^^^^22a3%
  ^^^^22a4^^^^22a5^^^^22c4^^^^2308^^^^230a^^^^2336^^^^2337^^^^2339%
  ^^^^233b^^^^233d^^^^233f^^^^2340^^^^2342^^^^2347^^^^2348^^^^2349%
  ^^^^234b^^^^234e^^^^2350^^^^2352^^^^2355^^^^2357^^^^2359^^^^235d%
  ^^^^235e^^^^235f^^^^2361^^^^2362^^^^2363^^^^2364^^^^2365^^^^2368%
  ^^^^236a^^^^236b^^^^236c^^^^2371^^^^2372^^^^2373^^^^2374^^^^2375%
  ^^^^2377^^^^2378^^^^237a^^^^2395^^^^25af^^^^25ca^^^^25cb%
  ^^00}
\lst@RestoreCatcodes
\makeatother

%XXX REMOVE FOR FINAL SUBMISSION
\usepackage{todonotes}
\newcommand{\TODO}[1]{\todo[inline]{#1}}
\usepackage{algorithm}
\usepackage{algorithmic}

\bibliographystyle{siam}

\title{Linguistic relativity and programming languages}

\author{%
    Jiahao Chen
    \thanks{Computer Science and Artificial Intelligence Laboratory,
           Massachusetts Institute of Technology,
           Cambridge, Massachusetts, 02139 ({\tt jiahao@mit.edu})}
    %
    %\and
    %Alan Edelman
    %\thanks{Department of Mathematics and Computer Science and Artificial Intelligence Laboratory,
    %        Massachusetts Institute of Technology,
    %        Cambridge, Massachusetts, 02139 ({\tt edelman@mit.edu})}
}


\begin{document}

\maketitle

\begin{abstract}
My abstract.
\end{abstract}

%XXX REMOVE BEFORE FINAL SUBMISSION
\listoftodos

\section{Linguistic relativity}

\section{Split-apply-combine and a stereotypical Uber}

\section{Uber example}

\section{Walking through the various implementations in a few different languages
what are the data structures and abstractions being used?}

\subsection{APL}

About APL

APL has only one data structure, the array.~\footnote{Some modern implementations such as Dyalog APL~\cite{dyalog15} have nonstandard extensions that provide support for object-oriented programming in the form of classes, but we won't consider them here} As such, the array is the only data structure available for the APL programmer to express computations in.

One implementation of the split-apply-combine workflow would be the following:

\begin{lstlisting}
mean←{+/⍵÷⍴⍵}
uniqfy←{⍵[⍋⍵]}∪
∇a←v splitby k
a←{(⍵⍷k)/v}¨uniqfy k
∇
sac←{(uniqfy ⍵),[1.5]mean¨(⍺ splitby ⍵)}
\end{lstlisting}
%
and a typical session of the APL interpreter invoking this function might look like:

\begin{lstlisting}
u←381 1291 3992 193942 9493 381 3992 381 3992 193942
r←5 4 4 4 5 5 5 3 5 4
]display r sac u
┌→─────────────────┐
↓   381 4.333333333│
│  1291 4          │
│  3992 4.666666667│
│  9493 5          │
│193942 4          │
└~─────────────────┘
\end{lstlisting}

A few salient features of APL are used in this implementation that are worth describing:

First, the primary data structure used to implement the ``split'' stage is the nested array. The nested array has long been advocated as the primary tool for statistical computation\cite{Anscombe1981,Friendly1994}. In this case, \lstinline|splitby| produces the result

\begin{lstlisting}
]display r splitby u
┌→──────────────────────────────┐
│ ┌→────┐ ┌→┐ ┌→────┐ ┌→┐ ┌→──┐ │
│ │5 5 3│ │4│ │4 5 5│ │5│ │4 4│ │
│ └~────┘ └~┘ └~────┘ └~┘ └~──┘ │
└∊──────────────────────────────┘
\end{lstlisting}

corresponding to the keys

\begin{lstlisting}
]display uniqfy u
┌→────────────────────────┐
│381 1291 3992 9493 193942│
└~────────────────────────┘
\end{lstlisting}

One should also note that there is a long tradition of writing concise one-line solutions to various problems. For this problem, it would be considered idiomatic to provide, instead of the user-defined \lstinline|sac| function, the one-liner

\begin{lstlisting}
{⍵,[1.5]{mean¨{(⍵⍷u)/r}¨⍵}¨⍵}{⍵[⍋⍵]}∪u
\end{lstlisting}

\section{Julia}

Julia's thesis is actually quite simple.
Why not design a language that is easy for both compilers and programmers to understand?
Why is language important anyway?

\section{Linguistic relativity and programming languages}

We now borrow a concept from the study of \textit{human} languages, that
of linguistic relativity, sometimes termed the Sapir--Whorf hypothesis.
Simply put, it is it idea that language determines or contrains cognition
dx.doi.org/10.1016/0010-0277(76)90001-9.

Here are some choice quotes from the namesakes Sapir and Whorf:

Human beings do not live in the objective world alone,[...] but are very much at
the mercy of the particular language which has become the medium of expression
for their society [...] [T]he `real world' is to a large extent unconsciously
built up on the language habits of the group.~\cite{Sapir1929}


Sapir wrote about human languages, in particular contrasting native American
languages like Hopi (XXX???) against Occidental languages like English. Nevertheless,
the words he has written are very much relevant to the real of programming
languages, which are by definition a human construct designed to abstract away
unwanted details about computers and their low level machine codes.
The ``language habits'' that Sapir write about originally refered to XXX
but have their parallels in programming language abstractions. Some examples of
these programming language habits may include:

``Always put data in a data frame''

``Never write for loops; vectorize your code to gain performance.''

``A vector is the same as a column matrix''

Some ``language habits'' can be as banal as choosing between 0- or 1-based
indexing, leading to notoriously unproductive flame wars.
Others are more subtle. For example, MATLAB treats vectors like column matrices,
and therefore allow operations on one-dimensional objects like
\lstinline|v[(2,1)]| indexing with two numbers, which are disallowed
in many other languages like C. We can trace the different indexing behaviors
back to different mathematical starting points---whereas most languages treat
vectors as one-dimensional arrays, i.e.\ ``flat'' sequences of numbers, MATLAB
by virtue of treating most objects like matrices, assumes that vectors by default
are \textit{column} vectors, and therefore behave just matrices with one column.

The fact that such discussions of language habits tend to be emotionally
charged is also not a coincidence.

[E]very person [...] carries through life certain na\"ive but deeply rooted
idea about talking and its relation to thinking. Because of their firm
connection with speech habits that have become unconscious and automatic, these
notions tend to be intolerant of opposition.~\cite{Whorf1956sl}


Replace ``talking'' with ``writing code'', and the analogy between speech and
computer programs could hardly be plainer. An experienced programmer,
practically by definition, internalizes the boilerplate and design patterns in
code as ``unconscious and automatic'' idioms to be regurgitated on demand
(preferably with an editor or IDE that helps reinforce these idioms automatically).
To the fluent Java programmer, wrapping everything in a class must be second nature,
just as the R user is accustomed to seeing data in a data frame, or whitespace
sensitivity to the Pythonista.
Allowing for code as a generalization of speech, one could argue that Whorf's
observation predicted the very phenomenon of flame wars over programming language
design!


Through [linguistic knowledge], the world as seen from the diverse viewpoints of
other social groups, that we have thought of as alien, becomes intelligible in
new terms. Alienness turns into a new and often clarifyign way of looking at
things.~\cite{Whorf1956lmr}


\section{A simple data science task}

Here is a simple data analysis task that is perhaps emblematic of our house
sharing, carpooling times. Suppose I am a data scientist working at a ride
sharing company and here are the user ratings data for the last ten trips taken
by a particular driver:

\begin{tabular}{r|rrrrrrrrrr}
userid &
381    & 1291   & 3992   & 193942 & 9493   &
381    & 3992   & 381    & 3992   & 193942 \tabularnewline
rating &
5 & 4 & 4 & 4 & 5 & 5 & 5 & 3 & 5 & 4
\end{tabular}

Suppose also that I am interested in working out the average rating given
by each unique userid.
A seasoned R user might immediately recognize this task as a
``split-apply-combine'' problem, which could be solved using the \lstinline|dplyr|
package as follows~\cite{Wickham2011}:

\begin{lstlisting}
> library(dplyr);
> userid = c(381, 1291, 3992, 193942, 9493, 381,
    3992, 381, 3992, 193942)
> rating = c(5, 4, 4, 4, 5, 5, 5, 3, 5, 4)
> mycar = data.frame(rating, userid)
> summarize(group_by(mycar, userid), avgrating=mean(rating))
# A tibble: 5 x 2
  userid avgrating
   <dbl>     <dbl>
1    381  4.333333
2   1291  4.000000
3   3992  4.666667
4   9493  5.000000
5 193942  4.000000
\end{lstlisting}

\TODO{dplyr paper cites several other implementations, notably ``APL’s array operators (Friendly and Fox 1994)''
Friendly M, Fox J (1994). “Using APL2 to Create an Object-Oriented Environment for Sta- tistical Computation.” Journal of Computational and Graphical Statistics, 3, 387–407.}

It turns out that MATLAB provides a higher order function, \lstinline|accumarray|,
which is designed specifically for this task!

\begin{lstlisting}
>> userids = [381 1291 3992 193942 9493 381 3992 381 3992 193942];
>> ratings = [5 4 4 4 5 5 5 3 5 4];
>> accumarray(userids',ratings',[],@mean,[],true)

ans =

                (381,1)                      4.3333
               (1291,1)                      4.0000
               (3992,1)                      4.6667
               (9493,1)                      5.0000
             (193942,1)                      4.0000
\end{lstlisting}

And finally we present APL, a language familiar to the ancients but to most
younger programmers may be barely recognizable as imperative code:

\lstinputlisting{code/summarize.apl}

A few details of the APL solution are worth explanining.

Defined functions in APL can take at most two arguments.
Further arguments must be specified in ``concealed arguments'', which are variables in global scope.

The APL code is equivalent to this one-liner

\begin{lstlisting}
mean←{+/⍵÷⍴⍵}
∇a←v sac k;u
u←{⍵[⍋⍵]}∪k
a←u,[1.5]{⊂mean(k=⍵)/v}¨u
∇
\end{lstlisting}

HEre is the ``split'' stage in APL:

\begin{lstlisting}
     {(u=⍵)/r}¨{⍵[⍋⍵]}∪u
5 5 3  4  4 5 5  5  4 4
\end{lstlisting}

which creates a nested array with all ratings for a particular userid in u.

The ``apply`` stage looks like

\begin{lstlisting}
    mean¨{(u=⍵)/r}¨{⍵[⍋⍵]}∪u
5 5 3  4  4 5 5  5  4 4
\end{lstlisting}


I won't bother to explain the syntax here, only to present a working APL code
to highlight the alienness that Whorf wrote about.

\section{Results}

\section{Conclusions}

\section*{Acknowledgments}

\bibliography{bib/bib}

\end{document}
